---
description: Structuring code for SwiftUI views
globs: **/features/**/Sources/**/*.swift
alwaysApply: false
---
## File content
For the UI layer, use a View + ViewModel pattern.
- The View model should be @Observable, and @MainActor when possible.
- Each view that can mutate an outside state should do this through its view model. Internal state should be managed with @State.
- For each view file, there should be a corresponding preview file that has several SwiftUI previews.
- When necessary to help test specific behaviors on the preview, you can also include in the preview file helpers (either static content, or wrapper views). All this optional helper code should be container in #if DEBUG / #endif.

## File structure
The file structure should be:
  - ./path/<Name>View.swift
  - ./path/<Name>View+Previews.swift
  - ./path/<Name>.swift (optional, for the view model)

When UI components have a clear nested hierarchy, also represent it in the file structure. For instance if an Input component is always contained in an ChatTab component, you should structure files:

./path/ChatTab.swift
./path/ChatTabView.swift
./path/ChatTabView+Previews.swift
./path/Input/Input.swift
./path/Input/InputView.swift
./path/Input/InputView+Previews.swift

If a component is not always nested in another one don't do it.

Generic UI components should be added to ./app/modules/coreui/DLS/ Example of such generic component would be a rounded button whose content and action is set by the caller.