// Copyright cmd app, Inc. Licensed under the Apache License, Version 2.0.
// You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0

import ConcurrencyFoundation
import Foundation
import JSONFoundation
import ServerServiceInterface
import ToolFoundation

// MARK: - AssistantMessage

/// One message generated by the assistant.
public struct AssistantMessage: Sendable {
  public let content: [AssistantMessageContent]

  public init(content: [AssistantMessageContent]) {
    self.content = content
  }
}

// MARK: - AssistantMessageContent

/// The content representing one part of the message (usually messages have only one part, but they can have more).
public enum AssistantMessageContent: Sendable { // TODO: rename to StreamedAssistantMessageContent for clarity?
  case text(_ message: MutableCurrentValueStream<TextContentMessage>)
  case reasoning(_ message: MutableCurrentValueStream<ReasoningContentMessage>)
  case tool(_ message: ToolUseMessage)
}

// MARK: - TextContentMessage

/// A message containing text.
public struct TextContentMessage: Sendable {
  // MARK: Lifecycle

  public init(content: String, deltas: [String] = []) {
    self.content = content
    self.deltas = deltas
  }

  // MARK: Public

  /// The content of the message. If the message is being streamed, this content might be incomplete.
  public let content: String
  /// When the message is being streamed, the deltas represent all the changes to the content that have been received.
  public let deltas: [String]
}

// MARK: - ReasoningContentMessage

/// A message containing text.
public struct ReasoningContentMessage: Sendable {
  // MARK: Lifecycle

  public init(content: String, deltas: [String] = [], signature: String? = nil) {
    self.content = content
    self.deltas = deltas
    self.signature = signature
  }

  // MARK: Public

  /// The content of the message. If the message is being streamed, this content might be incomplete.
  public let content: String
  /// When the message is being streamed, the deltas represent all the changes to the content that have been received.
  public let deltas: [String]
  /// The reasoning signature, if available.
  public let signature: String?
}

// public enum Reasoning

public typealias ToolUseRequestMessage = Schema.ToolUseRequest

// MARK: - ToolUseMessage

public struct ToolUseMessage: Sendable {
  public let toolUse: any ToolUse

  public init(toolUse: any ToolUse) {
    self.toolUse = toolUse
  }

  public var id: String { toolUse.toolUseId }
  public var toolName: String { toolUse.toolName }
  public var input: any Codable { toolUse.input }
}

extension Schema.ToolUseRequest {

  // TODO: Look at avoiding this decoding.
  public init(
    name: String,
    anyInput: any Codable,
    id: String)
    throws
  {
    let data = try JSONEncoder().encode(anyInput)
    let json = try JSONDecoder().decode(JSON.self, from: data)
    self.init(toolName: name, input: json, toolUseId: id, idx: 0)
  }
}
