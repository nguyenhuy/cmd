// Copyright Xcompanion. All rights reserved.
// Licensed under the XXX License. See License.txt in the project root for license information.

import ConcurrencyFoundation
import Foundation
import JSONFoundation
import ServerServiceInterface
import ToolFoundation

// MARK: - LLMModel

/// The LLM model used to generate a message.
public struct LLMModel: Hashable, Identifiable, CaseIterable, Sendable {
  public init?(rawValue: String) {
    if let model = Self.allCases.first(where: { $0.id == rawValue }) {
      self = model
    } else {
      return nil
    }
  }

  init(displayName: String, id: String) {
    self.displayName = displayName
    self.id = id
  }

  public static let claudeSonnet37 = LLMModel(displayName: "claude-3.7-sonnet", id: "claude-3-7-sonnet-20250219")
  public static let claudeSonnet40 = LLMModel(displayName: "claude-4.0-sonnet", id: "claude-sonnet-4-20250514")
  public static let gpt4o = LLMModel(displayName: "gpt-4o", id: "gpt-4o")
  public static let gpt4o_mini = LLMModel(displayName: "gpt-4o-mini", id: "gpt-4o-mini")
  public static let o1 = LLMModel(displayName: "o1", id: "o1-preview")

  public static let openRouterClaudeSonnet37 = LLMModel(
    displayName: "claude-3.7-sonnet (Open Router)",
    id: "anthropic/claude-3.7-sonnet")
  public static let openRouterClaudeSonnet40 = LLMModel(
    displayName: "claude-4.0-sonnet (Open Router)",
    id: "anthropic/claude-sonnet-4")
  public static let openRouterClaudeOpus4 = LLMModel(displayName: "claude-opus-4 (Open Router)", id: "anthropic/claude-opus-4")
  public static let openRouterClaudeHaiku35 = LLMModel(
    displayName: "claude-3.5-haiku (Open Router)",
    id: "anthropic/claude-3.5-haiku")
  public static let openRouterGpt41 = LLMModel(displayName: "gpt-4.1 (Open Router)", id: "openai/gpt-4.1")
  public static let openRouterGpt4o = LLMModel(displayName: "gpt-4o (Open Router)", id: "openai/gpt-4o")
  public static let openRouterO4Mini = LLMModel(displayName: "o4-mini (Open Router)", id: "openai/o4-mini")

  public static var allCases: [LLMModel] {
    [
      .claudeSonnet40,
      .claudeSonnet37,
      .gpt4o,
      .gpt4o_mini,
      .o1,
      .openRouterClaudeSonnet37,
      .openRouterClaudeSonnet40,
      .openRouterClaudeOpus4,
      .openRouterClaudeHaiku35,
      .openRouterGpt41,
      .openRouterGpt4o,
      .openRouterO4Mini,
    ]
  }

  public let displayName: String
  public let id: String

}

// MARK: - AssistantMessage

/// One message generated by the assistant.
public struct AssistantMessage: Sendable {
  public let content: [AssistantMessageContent]

  public init(content: [AssistantMessageContent]) {
    self.content = content
  }
}

// MARK: - AssistantMessageContent

/// The content representing one part of the message (usually messages have only one part, but they can have more).
public enum AssistantMessageContent: Sendable {
  case text(_ message: MutableCurrentValueStream<TextContentMessage>)
  case tool(_ message: ToolUseMessage)
}

// MARK: - TextContentMessage

/// A message containing text.
public struct TextContentMessage: Sendable {
  // MARK: Lifecycle

  public init(content: String, deltas: [String] = []) {
    self.content = content
    self.deltas = deltas
  }

  // MARK: Public

  /// The content of the message. If the message is being streamed, this content might be incomplete.
  public let content: String
  /// When the message is being streamed, the deltas represent all the changes to the content that have been received.
  public let deltas: [String]
}

public typealias ToolUseRequestMessage = Schema.ToolUseRequest

// MARK: - ToolUseMessage

public struct ToolUseMessage: Sendable {
  public let toolUse: any ToolUse

  public init(toolUse: any ToolUse) {
    self.toolUse = toolUse
  }

  public var id: String { toolUse.toolUseId }
  public var toolName: String { toolUse.toolName }
  public var input: any Codable { toolUse.input }
}

extension Schema.ToolUseRequest {

  // TODO: Look at avoiding this decoding.
  public init(
    name: String,
    anyInput: any Codable,
    id: String)
    throws
  {
    let data = try JSONEncoder().encode(anyInput)
    let json = try JSONDecoder().decode(JSON.self, from: data)
    self.init(toolName: name, input: json, toolUseId: id)
  }
}
