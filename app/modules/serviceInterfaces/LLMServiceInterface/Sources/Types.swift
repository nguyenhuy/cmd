// Copyright Xcompanion. All rights reserved.
// Licensed under the XXX License. See License.txt in the project root for license information.

import ConcurrencyFoundation
import Foundation
import JSONFoundation
import ServerServiceInterface
import ToolFoundation

// MARK: - AssistantMessage

/// One message generated by the assistant.
public struct AssistantMessage: Sendable {
  public let content: [AssistantMessageContent]

  public init(content: [AssistantMessageContent]) {
    self.content = content
  }
}

// MARK: - AssistantMessageContent

/// The content representing one part of the message (usually messages have only one part, but they can have more).
public enum AssistantMessageContent: Sendable {
  case text(_ message: MutableCurrentValueStream<TextContentMessage>)
  case tool(_ message: ToolUseMessage)
}

// MARK: - TextContentMessage

/// A message containing text.
public struct TextContentMessage: Sendable {
  // MARK: Lifecycle

  public init(content: String, deltas: [String] = []) {
    self.content = content
    self.deltas = deltas
  }

  // MARK: Public

  /// The content of the message. If the message is being streamed, this content might be incomplete.
  public let content: String
  /// When the message is being streamed, the deltas represent all the changes to the content that have been received.
  public let deltas: [String]
}

public typealias ToolUseRequestMessage = Schema.ToolUseRequest

// MARK: - ToolUseMessage

public struct ToolUseMessage: Sendable {
  public let toolUse: any ToolUse

  public init(toolUse: any ToolUse) {
    self.toolUse = toolUse
  }

  public var id: String { toolUse.toolUseId }
  public var toolName: String { toolUse.toolName }
  public var input: any Codable { toolUse.input }
}

extension Schema.ToolUseRequest {

  // TODO: Look at avoiding this decoding.
  public init(
    name: String,
    anyInput: any Codable,
    id: String)
    throws
  {
    let data = try JSONEncoder().encode(anyInput)
    let json = try JSONDecoder().decode(JSON.self, from: data)
    self.init(toolName: name, input: json, toolUseId: id, idx: 0)
  }
}
