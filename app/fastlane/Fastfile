default_platform(:mac)

# Load a secret from the keychain if it is not passed as an environment variable.
require 'base64'

# A helper that loads a secret from the environment variable or the keychain.
def load_secret(env_key)
  if ENV[env_key]
    unless ENV['CI']
      # When the secret is passed as an environment variable locally, we store it in the keychain for future use.
      puts "Writting secret to keychain: #{env_key}"
      # Use base64 encoding to avoid dealing with new lines.
      sh("security add-generic-password -a '#{ENV['USER']}' -s 'dev.getcmd.#{env_key}' -w '#{Base64.strict_encode64(ENV[env_key])}' -U")
    end
    return ENV[env_key]
  end
  
  puts "Loading secret from keychain: #{env_key}"
  encoded = `security find-generic-password -s 'dev.getcmd.#{env_key}' -w 2>/dev/null`.strip
  return nil if encoded.empty?
  decoded = Base64.decode64(encoded)
  ENV[env_key] = decoded
end

platform :mac do
  desc "Build the app in Debug configuration"
  lane :build_debug do
    build_mac_app(
      project: "./command.xcodeproj",
      configuration: "Debug",
      skip_archive: true,
      scheme: "command",
      # silent: true,
      xcodebuild_formatter: "cat",
    )
  end

  desc "Build and archive the app for Mac App Store distribution"
  lane :build_release do
    setup_ci if ENV['CI']

    # Resolve package dependencies first. This is to work around an issue where CI would freeze.
    sh("xcodebuild -resolvePackageDependencies -scheme command -project ../command.xcodeproj -configuration Release -derivedDataPath build/derived_data -onlyUsePackageVersionsFromResolvedFile -parallelizeTargets")

    # use a fine grained token with permissions for: Contents, Metadata (maybe also commit statuses and pull requests)
    personal_github_access_token = load_secret("FASTLANE_MACH_REPO_GITHUB_ACCESS_TOKEN")
    ENV['MATCH_PASSWORD'] = load_secret("MATCH_PASSWORD")
    readonly = true
    # The fine grained token should have permissions for: Contents, Metadata (maybe also commit statuses and pull requests)
    # I could not find how to pass it in the header. It is in the git URL. If it is not set, like when running locally and saving new certificates, we need to use the SSH URL.
    git_url = readonly ? "https://gsabran:#{personal_github_access_token}@github.com/gsabran/command-provisioning-profiles.git" : "git@github.com:gsabran/command-provisioning-profiles.git"
    match(
      type: 'development',
      team_id: 'GP78T2GNXD',
      readonly: readonly,
      git_url: git_url
    )

    sh("../tools/release/configure_xcodeproj_for_release_build.sh")
    build_mac_app(
      destination: "platform=macOS,arch=arm64",
      skip_package_dependencies_resolution: true,
      project: "./command.xcodeproj",
      configuration: "Release", 
      export_method: "mac-application",
      output_directory: "build/release",
      derived_data_path: "build/derived_data",
      output_name: "command.app",
      scheme: "command",
      # silent: true,
      skip_archive: true,
      xcodebuild_formatter: "cat",
      export_options: {
        method: "development",
      },
    )
    sh("../tools/release/cleanup_xcodeproj_after_release_build.sh")
  end

  desc "Build, archive and sign the app for distribution"
  lane :create_and_sign_release do |options|
    setup_ci if ENV['CI']
    remove_zip = options.fetch(:remove_zip, true)
    version = options.fetch(:version, nil)

    # Resolve package dependencies first. This is to work around an issue where CI would freeze.
    sh("xcodebuild -resolvePackageDependencies -scheme command -project ../command.xcodeproj -configuration Release -derivedDataPath build/derived_data -onlyUsePackageVersionsFromResolvedFile -parallelizeTargets")

    # use a fine grained token with permissions for: Contents, Metadata (maybe also commit statuses and pull requests)
    personal_github_access_token = load_secret("FASTLANE_MACH_REPO_GITHUB_ACCESS_TOKEN")
    ENV['MATCH_PASSWORD'] = load_secret("MATCH_PASSWORD")
    readonly = true
    # The fine grained token should have permissions for: Contents, Metadata (maybe also commit statuses and pull requests)
    # I could not find how to pass it in the header. It is in the git URL. If it is not set, like when running locally and saving new certificates, we need to use the SSH URL.
    git_url = readonly ? "https://gsabran:#{personal_github_access_token}@github.com/gsabran/command-provisioning-profiles.git" : "git@github.com:gsabran/command-provisioning-profiles.git"
    
    match(
      type: 'developer_id',
      team_id: 'GP78T2GNXD',
      readonly: readonly,
      git_url: git_url
    )
    update_code_signing_settings(
      code_sign_identity: 'Developer ID Application',
      use_automatic_signing: false,
      path: "./command.xcodeproj"
    )

    # Build and archive the app
    sh("../tools/release/configure_xcodeproj_for_release_build.sh")
    build_path = File.absolute_path("../build")
    release_path = "#{build_path}/release"
    app_name = "command"
    app_path = "#{release_path}/#{app_name}.app"
    build_mac_app(
      destination: "platform=macOS,arch=arm64",
      skip_package_dependencies_resolution: true,
      project: "./command.xcodeproj",
      configuration: "Release",
      export_method: "developer-id",
      output_directory: release_path,
      derived_data_path: "#{build_path}/derived_data",
      output_name: app_name,
      scheme: "command",
      # silent: true,
      skip_archive: false,
      xcodebuild_formatter: "cat",
    )

    sh("../tools/release/cleanup_xcodeproj_after_release_build.sh")

    # Notarize the app
    app_store_connect_api_key(
      key_id: load_secret("NOTARY_KEY_ID"),
      issuer_id: load_secret("NOTARY_ISSUER_ID"),
      key_content: load_secret("NOTARY_P8"),
    )

    notarize(
      package: app_path,
      verbose: false,
      print_log: true,
      use_notarytool: true
    )

    # Create metadata for the new release

    # we need to re-package after notarization and stapling.
    # we have to use `ditto --sequesterRsrc` rather than zip
    # because the default strategy stores resource forks as
    # ._Foo but codesigning doesn't like that, and instead
    # wants them in __MACOSX.
    app_zip_path = "#{app_path}.zip"
    sh(
      "ditto", "-c", "-k", "--keepParent", "--sequesterRsrc",
      app_path, app_zip_path,
    )
    sparkle_path = "#{build_path}/derived_data/SourcePackages/artifacts/sparkle/Sparkle"

    sparkle_secret_key = load_secret("SPARKLE_SECRET_KEY")

    sparkle_output = sh("echo '#{sparkle_secret_key}' | #{sparkle_path}/bin/sign_update #{app_zip_path} --ed-key-file -")
    app_config_path = File.absolute_path("../command.shared.xcconfig")
    version = version || sh("cat #{app_config_path} | grep APP_VERSION=").split("APP_VERSION=").last.strip

    puts "Notarization completed successfully. version: #{version}, app_path: #{app_path}"

    appcast_template_path = File.absolute_path("./appcast.template.xml")
    appcast_path = File.absolute_path("./appcast.xml")
    appcast_content = File.read(appcast_template_path)
    appcast_content.gsub!("REPLACE_SPARKLE_VERSION", version)
    appcast_content.gsub!("REPLACE_SPARKLE_DESCRIPTION", "Test description for the release\nnew line")
    appcast_content.gsub!("REPLACE_SPARKLE_SIGN_UPDATE", sparkle_output)
    File.write(appcast_path, appcast_content)

    sh("rm -rf #{build_path}") if remove_zip
    { version: version, app_zip_path: app_zip_path, build_path: build_path }
  end

  desc "Build, archive, sign and publish the app for distribution"
  lane :distribute_release do
    setup_ci if ENV['CI']
    app_config_path = File.absolute_path("../command.shared.xcconfig")
    version = sh("cat #{app_config_path} | grep APP_VERSION=").split("APP_VERSION=").last.strip
    # Look for an existing version tag. If one exist, bump the version.
    existing_version = sh("git ls-remote origin refs/tags/v#{version}").strip
    if existing_version.empty?
      puts "Using version: #{version}"
    else
      version_parts = version.split('.')
      version_parts[-1] = (version_parts[-1].to_i + 1).to_s
      new_version = version_parts.join('.')
      puts "Bumping version from #{version} to #{new_version}."

      sh("sed -i '' 's/APP_VERSION=#{version}/APP_VERSION=#{new_version}/' #{app_config_path}")
      version = new_version
    end

    result = create_and_sign_release(remove_zip: false, version: version)
    version = result[:version]
    app_zip_path = result[:app_zip_path]
    build_path = result[:build_path]

    gh_personal_access_token_cmd = load_secret("GH_WRITE_TOKEN")

    set_github_release(
      api_token: gh_personal_access_token_cmd,
      server_url: "https://api.github.com",
      repository_name: "getcmd-dev/cmd",
      name: "v#{version}",
      tag_name: "v#{version}",
      description: "v#{version}",
      commitish: "main",
      upload_assets: app_zip_path
    )

    sh("rm -rf #{build_path}")

    new_branch_name = "release-v#{version}"
    sh("git checkout -b #{new_branch_name} && git add ..  && git commit -m 'Release v#{version}' --no-verify && git push origin #{new_branch_name} --no-verify")
    create_pull_request(
      api_token: gh_personal_access_token_cmd,
      title: "Release v#{version}",
      repo: "getcmd-dev/cmd",
      head: new_branch_name,
      base: "main"
    )
  end
end
